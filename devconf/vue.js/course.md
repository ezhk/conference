# Концепты VueJS для backend разработчков
Фронт сегодня:
- VueJS
- TS (type script)
- Sass

Webpack — позволяет упаковывать приложения, чтобы показать их браузеру, который в дальнейшем их отрисовывает. То есть превращает нашу логику в набор для браузера: HTML, JS, CSS, Media.  
Babel — транслятор JS6 в старый JS, чтобы код работал в старых браузерах.  
yarn/npm — пакетные менеджеры.  
Webpack + babel нужны для того, чтобы превратить наш код в то, что поймет браузер.  

JS сегодня:
- появились class
- появились короткие функции (стрелочные функции), которые сразу возвращают значения
- оператор `...`, который встраивает объект в другой объект (`{..foo, b: [...arr, 5]}`), причем можно делать деструктуризацию объекта
- `const {c} = a;` = `c = a.c`
- template string: \`some ${vars}\`

Магия VueJS - есть template (`Hello, {{name}}`) и данные (`data: {name: 'world'}`) и на выходе строка `Hello, world`.  

Virtual DOM (VD) — модель реального DOM, которую браузер не отрисовывает:
- чистый JS
- невероятно быстрый (реальный DOM очень медленный — браузер пытается определить размер и прочее, поэтому лучше сразу сделать 1000 div-ов виртуально и применить их)
- управляет реальным DOM
- не зависит от содержимого страницы

Во VueJS VD отвечает за то, что в дальнейшем будет передано браузеру, один раз будет перенесено и применено на реальную модель.  

Набор HTML в базовом виде:
```
<node atr=val>
...children...
</node>
```
node — это тег или #text

VueJS сгеренирует на основании нашего template JS код, который построит HTML, то есть шаблона в виде HTML не существует, есть JS код.  

Реактивность — отлавливание обращений в определенным переменным — во VueJS. VueJS запоминает какие переменные использовались в ноде и при изменении отправляет в модель виртуального измененные данные и происходит rerender блока. Если использовать не реактивные методы объектов, то VueJS может об этом не узнать (но push в этом месте реактивный, как и set). **Чтобы гарантирована работала реактивность, надо создать новый объект и присвоить его.**  

Vue $forceupdate — если мы что-то сделали и страница не изменилась, то мы можем обновить весь компонент (помогает в browser extension).  
Во Vue в первую очередь надо определить состояние — DATA, с которым мы работаем. Это данные влияют на шаблон (который через программы тоже может влиять на данные). Можно внедрять через proxy данные снаружи. А дальше через computed component поставляем измененные данные в шаблон.

```
       TEMPALTE
    ^           ||
    |           ||
computed <--  data  <-- props
             |    ^
             |    |
           watch  |
             |    |
             program --> events
```

Изменение computed свойства отправляет событие наверх, аналогично когда описываем watch. Те свойства, которые добавляются к модели, могут не объявляться. При работе с getter и setter реактивность также может не работать, поскольку они могут не обладать свойством реактивности (но могут и обернуться в reactiveGetter и reactiveSetter — надо смотреть в свойствах модели в отладчике). В этом случае getter и setter можно унести в методы.  

**v-bind** — `добавляет attrs: {"name": value}`, имя аттрибута значения не имеет и сам аттрибут становится реактивным. Также есть staticClass и dynamic class (аттрибут = class). `v-bind:value="newName"` — соращенно `:value="newName"` — устанавливаем значение newName из JS.
**v-model** обеспечивает 2-стороннее связывание, например, в случае с input мы также обновляем значение в data. Он смотрит в элемент куда встроили и связывается с value. v-model.number = вход, только число, и on change событие `v-model.number.lazy`.  
**v-on:change** — поможет заменить v-model: `v-on:change="$event"` — это JS event, у которого уже могут быть значения и можно сделать: `v-on:change="newName = $event.target.value"` и `v-on:change` можно заменить на `@change`.  

Если хотим что-то получить снаружи, то объявляем props рядом с data и потом компоненту объявляем как `<Test variable="test"/>`. Но props менять нельзя, он read-only. Но есть немного магии с emit: `@input="$emit('', $event.target.value)"`:
```
<input type="text" @input="$emit('title', $event.target.value)" :value="value"/>
<Test @variable="title = event.target.value"/>
```
или `<Test v-model="title"/>` при это emit остается, то есть emit — прокидывание event в реактивную компоненту, но логика та же: вниз — данные, вверх — event-ы.  

Ещё можно пробросить `:dispatcher`:
```
mounted() {
  this.dispatcher.$on('some', data => this.newName = data);
}
```

Но можно использовать [Vuex](https://vuex.vuejs.org/ru/guide/).  
**Vuex** — для хранения данных между переходами по страницам — глобальны для приложения. Но если приложение vue перезапустится, то vuex пересоздатся.  
 Vuex _встраивается в приложение через computed_. Причем сам vuex read-only, то он может отправлять запрос на изменения данных, также есть инкрементальные изменения — _timemachine_.  
 ```
 computed: {
    ...mapGetters(['user', ])}, // helper
    user() {
        return this.$store.getters.user,
    },
},
 ```
 helper подмешивает данные из vuex (по умолчанию read-only, или необходимо использовать мутации):  
 у vuex есть state и есть getters, но чтобы обратно поместить данные в стейт — надо использовать мутации (+ создается слепок timemachine), и есть actions — которые делают какую-то логику и затем вызывают мутацию.  
 
 Чем плох подход, когда front и backend API — отдельно:
 - 2 домена (для фронта и бека), или отдельная логика на nginx
 - 2 репозитория — сложнее ревьювить
 - CORS (cross origin requests)
 - деплой усложняется
 - два состояния (например, пользователь может быть удален на беке, но существовать на фронте)
 
 На бекенде генерируется страница, которая стартует VueJS приложение. И можем вклеить данные в это vueJS приложение из бекенда, то есть VueJS может быть именно рендерером.  
 