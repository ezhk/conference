# Тестирование приложений
[Slides](https://github.com/sobolevn/heisenbug-2019)

Больше тестов = больше кода = больше багов и дубликатов = CI — слабое место, долго.
Повысим покрытие, но это мало, нужны проверки.

Тестируете ли вы тесты?

- будем строже ревьювить, чтобы не упускать в тестах assert и пр.
- читаемость тестов можно повышать (linter)

Вносим в тесты небольшие отклонения, менять построчно — проверяем:

- тесты упадут и убьют мутанта
- timeout
- пропустили проверку:
    - берем синтаксическое дерево
    - заменяем части AST на похожие (True -> False, x -> not x)

Инструменты:

- cosmic ray
- mutpy
- **mutmut** — интеграция с pytest, но сырой инструмент

Рекомендации:

1. Любая отдельная логика должна быть вынесена в функцию и отдельно протестирована.
2. Ставьте timeout-ы — pytest-timeout.
3. Pragme no mutate — игнорируем мутантов, но можно выборочно использовать .patch, а ещё лучше запускать конкретный тест (--path-to-mutate)

Ускорение тестов:

- отключение plugin (coverage, etc)
- убираем вывод
- проверяем до первой fail
- используй coverage (используй то, что покрыто coverage — не надо тестировать всё)
- pytest-testmon — анализирует код и смотрит какие кусочки покрыты coverage
- можем делать --post-mutation, смотрим тесты, которые никогда не падают — избавляемся от ненужного

Как писать код TDD:

- пишем код
- пишем тесты
- мутируем код
- мутируем тесты

Выводы:
- мы не пишем больше тестов — мы пишем лучше тесты
- мы не повышает покрытие — мы за результат
- мы не ревьювим тесты — мутируем код


# Avito python stack
- tornado + async event loop
- django для админки
- postgresql + redis-cache
- pipeline: ETL между Vertica и БД


# Что делать если ваш код на Python тормозит
Испольхование аннотаций — best practice.
Ускорение кода:

- cython — можно быстро запустить программу ускорив её (ускорение почти в 2 раза) — бинарный можуль
    - .py -> .pyx rename
    - cythonize -a -i modulename.pyx
    - у него есть собственный язык (там есть часть логики похожей на C), научился считать type annotation от python — **очень быстро получилось** — C код со своим бинарником
- pypy3 (не весь синтаксис 3 питона поддерживает, на уровне 3.5-3.6) — ускорение в 10 раз, это альтернативный интерпретатор с другим подходом
- numba, свойства компиляции определенных частей кода: но получили отрицательный результат — плохо работает со строками
- grumpy, но рассчитан на python 2.6 и HEAD сломан — не работает
- pybindgen (программа на Go и биндинги в python) — работает медленнее чем py3.7
- **nim** (и пророк его numpy) — выносим логику подсчета суммы символов в строке (nic c --app:lib --out:csc.so csc.nim) — готовый бинарный модуль на выходе, ускорение примерно как с pypy3, синтаксис очень похож на python

Рефакторинг кода:

- вынесение операций из цикла, если это можно сделать

Мораль:

- в большинстве случаев достаточно pypy
- оптимизация простого кода тоже важна
- инструментарий должен быть стабильным
- если ваш проект, то нет ничего плохого в изотерических языках (например, nim)
- но не стоит всегда быть в погоне за новыми инструментами: в большинстве случаев достаточно получить производительности в 10x

На что обратить внимание?

- [graalvmn](https://github.com/graalvm/graalpython)
- [cppyy](http://doc.pypy.org/en/release-2.4.x/cppyy.html)
- [nuitka](http://nuitka.net/) — без особого развития
